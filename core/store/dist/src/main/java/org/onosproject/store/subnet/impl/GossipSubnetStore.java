/*
 * Copyright 2014 Open Subneting Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onosproject.store.subnet.impl;

import static org.slf4j.LoggerFactory.getLogger;

import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentMap;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.Service;
import org.onosproject.net.NetworkId;
import org.onosproject.net.Subnet;
import org.onosproject.net.SubnetId;
import org.onosproject.net.networks.NetworkStore;
import org.onosproject.net.provider.ProviderId;
import org.onosproject.net.subnet.SubnetDescription;
import org.onosproject.net.subnet.SubnetEvent;
import org.onosproject.net.subnet.SubnetStore;
import org.onosproject.net.subnet.SubnetStoreDelegate;
import org.onosproject.store.AbstractStore;
import org.slf4j.Logger;

import com.google.common.collect.Maps;

/**
 * Manages inventory of infrastructure subnets using gossip protocol to
 * distribute information.
 */
@Component(immediate = true)
@Service
public class GossipSubnetStore
        extends AbstractStore<SubnetEvent, SubnetStoreDelegate>
        implements SubnetStore {

    private final Logger log = getLogger(getClass());
    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected NetworkStore store;
    private static final String SUBNET_NOT_FOUND = "Device with ID %s not found";

    // cache of Device and Ports generated by compositing descriptions from
    // providers
    private final ConcurrentMap<SubnetId, Subnet> subnets = Maps
            .newConcurrentMap();

    @Activate
    public void activate() {
        log.info("Started");
    }

    @Deactivate
    public void deactivate() {
        subnets.clear();
        log.info("Stopped");
    }

    @Override
    public int getSubnetCount() {
        return subnets.size();
    }

    @Override
    public Iterable<Subnet> getSubnets() {
        log.info("getSubnets+++++++++++++++gossip =======" + subnets.toString());
        return Collections.unmodifiableCollection(subnets.values());
    }

    @Override
    public Subnet getSubnet(SubnetId subnetId) {
        if (!subnetExists(subnetId)) {
            return null;
        }
        return subnets.get(subnetId);
    }
    @Override
    public boolean subnetExists(SubnetId subnetId) {
        return subnets.containsKey(subnetId);
    }

    /**
     * @Override public boolean removeSubnet(SubnetId subnetId) { if
     *           (subnetExists(subnetId)) { return false; } Subnet subnet =
     *           subnets.remove(subnetId); return subnet == null ? true : false;
     *           }
     * @Override public boolean subnetcreate(Subnet subnet) { if
     *           (subnetExists(subnet.id())) { return false; }
     *           subnets.putIfAbsent(subnet.id(), subnet); return true; }
     * @Override public boolean subnetupdate(SubnetId subnetId, Subnet subnet) {
     *           if (subnetExists(subnetId)) { return false; } return false; }
     */
    @Override
    public Iterable<Subnet> getAvailableSubnets() {
        // TODO Auto-generated method stub
        return Collections.unmodifiableCollection(subnets.values());
    }

    @Override
    public SubnetEvent createOrUpdateSubnet(ProviderId providerId,
                                            SubnetId subnetId,
                                            SubnetDescription subnetDescription) {
        // TODO Auto-generated method stub
        Subnet subnet = subnets.remove(subnetId);
        return subnet == null ? null
                             : new SubnetEvent(SubnetEvent.Type.SUBNET_REMOVED,
                                               subnet, null);
    }

    @Override
    public boolean createSubnet(Iterable<Subnet> subnetIts) {
        Iterator<Subnet> subnetIo = subnetIts.iterator();
        while (subnetIo.hasNext()) {
            Subnet subnet = subnetIo.next();
            if (subnetExists(subnet.id())) {
                return false;
            }
            if (!store.networkExists(NetworkId.networkId(subnet.networkID()))) {
                return false;
            }
            subnets.putIfAbsent(subnet.id(), subnet);
        }
        return true;

    }

    @Override
    public boolean updateSubnet(Iterable<Subnet> subnetIts) {
        Boolean flag = false;
        Iterator<Subnet> subnetIo = subnetIts.iterator();
        while (subnetIo.hasNext()) {
            Subnet subnet = subnetIo.next();
            subnets.putIfAbsent(subnet.id(), subnet);
            flag = true;
        }
        return flag;
    }

    @Override
    public SubnetEvent removeSubnet(SubnetId subnetId) {
        // TODO Auto-generated method stub
        Subnet subnet = subnets.remove(subnetId);
        return subnet == null ? null
                             : new SubnetEvent(SubnetEvent.Type.SUBNET_REMOVED,
                                               subnet, null);
    }

}
