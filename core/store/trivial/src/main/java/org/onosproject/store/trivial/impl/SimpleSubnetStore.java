/*
 * Copyright 2014 Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onosproject.store.trivial.impl;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Verify.verify;
import static org.onosproject.net.DefaultAnnotations.merge;
import static org.onosproject.net.DefaultAnnotations.union;
import static org.slf4j.LoggerFactory.getLogger;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Service;
import org.onosproject.net.AnnotationsUtil;
import org.onosproject.net.DefaultAnnotations;
import org.onosproject.net.DefaultSubnet;
import org.onosproject.net.Port;
import org.onosproject.net.PortNumber;
import org.onosproject.net.SparseAnnotations;
import org.onosproject.net.Subnet;
import org.onosproject.net.SubnetId;
import org.onosproject.net.device.DefaultPortDescription;
import org.onosproject.net.device.PortDescription;
import org.onosproject.net.provider.ProviderId;
import org.onosproject.net.subnet.DefaultSubnetDescription;
import org.onosproject.net.subnet.SubnetDescription;
import org.onosproject.net.subnet.SubnetEvent;
import org.onosproject.net.subnet.SubnetStore;
import org.onosproject.net.subnet.SubnetStoreDelegate;
import org.onosproject.store.AbstractStore;
import org.slf4j.Logger;

import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

/**
 * Manages inventory of infrastructure subnets using trivial in-memory
 * structures implementation.
 */
@Component(immediate = true)
@Service
public class SimpleSubnetStore
        extends AbstractStore<SubnetEvent, SubnetStoreDelegate>
        implements SubnetStore {

    private final Logger log = getLogger(getClass());

    public static final String SUBNET_NOT_FOUND = "Subnet with ID %s not found";

    // Collection of Description given from various providers
    private final ConcurrentMap<SubnetId, Map<ProviderId, SubnetDescriptions>> subnetDescs = Maps
            .newConcurrentMap();

    // Cache of Subnet and Ports generated by compositing descriptions from
    // providers
    private final ConcurrentMap<SubnetId, Subnet> subnets = Maps
            .newConcurrentMap();
    private final ConcurrentMap<SubnetId, ConcurrentMap<PortNumber, Port>> subnetPorts = Maps
            .newConcurrentMap();

    // Available (=UP) subnets
    private final Set<SubnetId> availableSubnets = Sets.newConcurrentHashSet();

    @Activate
    public void activate() {
        log.info("Started");
    }

    @Deactivate
    public void deactivate() {
        subnetDescs.clear();
        subnets.clear();
        subnetPorts.clear();
        availableSubnets.clear();
        log.info("Stopped");
    }

    @Override
    public int getSubnetCount() {
        return subnets.size();
    }

    @Override
    public Iterable<Subnet> getSubnets() {
        return Collections.unmodifiableCollection(subnets.values());
    }

    @Override
    public Iterable<Subnet> getAvailableSubnets() {
        return null;
    }

    @Override
    public Subnet getSubnet(SubnetId subnetId) {
        return subnets.get(subnetId);
    }

    @Override
    public SubnetEvent createOrUpdateSubnet(ProviderId providerId,
                                            SubnetId subnetId,
                                            SubnetDescription subnetDescription) {
        Map<ProviderId, SubnetDescriptions> providerDescs = getOrCreateSubnetDescriptions(subnetId);

        synchronized (providerDescs) {
            // locking per subnet
            SubnetDescriptions descs = getOrCreateProviderSubnetDescriptions(providerDescs,
                                                                             providerId,
                                                                             subnetDescription);

            Subnet oldSubnet = subnets.get(subnetId);
            // update description
            descs.putSubnetDesc(subnetDescription);
            Subnet newSubnet = composeSubnet(subnetId, providerDescs);

            if (oldSubnet == null) {
                // ADD
                return createSubnet(providerId, newSubnet);
            } else {
                // UPDATE or ignore (no change or stale)
                return updateSubnet(providerId, oldSubnet, newSubnet);
            }
        }
    }

    // Creates the subnet and returns the appropriate event if necessary.
    // Guarded by subnetDescs value (=Subnet lock)
    private SubnetEvent createSubnet(ProviderId providerId, Subnet newSubnet) {
        // update composed subnet cache
        Subnet oldSubnet = subnets.putIfAbsent(newSubnet.id(), newSubnet);
        verify(oldSubnet == null,
               "Unexpected Subnet in cache. PID:%s [old=%s, new=%s]",
               providerId, oldSubnet, newSubnet);

        if (!providerId.isAncillary()) {
            availableSubnets.add(newSubnet.id());
        }

        return new SubnetEvent(SubnetEvent.Type.SUBNET_ADDED, newSubnet, null);
    }

    // Updates the subnet and returns the appropriate event if necessary.
    // Guarded by subnetDescs value (=Subnet lock)
    private SubnetEvent updateSubnet(ProviderId providerId, Subnet oldSubnet,
                                     Subnet newSubnet) {
        // We allow only certain attributes to trigger update
        boolean propertiesChanged = !Objects.equals(oldSubnet.ipVersion(),
                                                    newSubnet.ipVersion());
        boolean annotationsChanged = !AnnotationsUtil.isEqual(oldSubnet
                .annotations(), newSubnet.annotations());

        // Primary providers can respond to all changes, but ancillary ones
        // should respond only to annotation changes.
        if ((providerId.isAncillary() && annotationsChanged)
                || (!providerId.isAncillary() && (propertiesChanged || annotationsChanged))) {

            boolean replaced = subnets.replace(newSubnet.id(), oldSubnet,
                                               newSubnet);
            if (!replaced) {
                // FIXME: Is the enclosing if required here?
                verify(replaced,
                       "Replacing subnets cache failed. PID:%s [expected:%s, found:%s, new=%s]",
                       providerId, oldSubnet, subnets.get(newSubnet.id()),
                       newSubnet);
            }
            if (!providerId.isAncillary()) {
                availableSubnets.add(newSubnet.id());
            }
            return new SubnetEvent(SubnetEvent.Type.SUBNET_UPDATED, newSubnet,
                                   null);
        }

        // Otherwise merely attempt to change availability if primary provider
        if (!providerId.isAncillary()) {
            boolean added = availableSubnets.add(newSubnet.id());
            return !added ? null : new SubnetEvent(SubnetEvent.Type.SUBNET_AVAILABILITY_CHANGED,
                                                   newSubnet, null);
        }
        return null;
    }

    private Map<ProviderId, SubnetDescriptions> getOrCreateSubnetDescriptions(SubnetId subnetId) {
        Map<ProviderId, SubnetDescriptions> r;
        r = subnetDescs.get(subnetId);
        if (r != null) {
            return r;
        }
        r = new HashMap<>();
        final Map<ProviderId, SubnetDescriptions> concurrentlyAdded;
        concurrentlyAdded = subnetDescs.putIfAbsent(subnetId, r);
        if (concurrentlyAdded != null) {
            return concurrentlyAdded;
        } else {
            return r;
        }
    }

    // Guarded by subnetDescs value (=Subnet lock)
    private SubnetDescriptions getOrCreateProviderSubnetDescriptions(Map<ProviderId, SubnetDescriptions> subnet,
                                                                     ProviderId providerId,
                                                                     SubnetDescription deltaDesc) {
        synchronized (subnet) {
            SubnetDescriptions r = subnet.get(providerId);
            if (r == null) {
                r = new SubnetDescriptions(deltaDesc);
                subnet.put(providerId, r);
            }
            return r;
        }
    }


    @Override
    public SubnetEvent removeSubnet(SubnetId subnetId) {
        Map<ProviderId, SubnetDescriptions> descs = getOrCreateSubnetDescriptions(subnetId);
        synchronized (descs) {
            Subnet subnet = subnets.remove(subnetId);
            // should SUBNET_REMOVED carry removed ports?
            Map<PortNumber, Port> ports = subnetPorts.get(subnetId);
            if (ports != null) {
                ports.clear();
            }
            availableSubnets.remove(subnetId);
            descs.clear();
            return subnet == null ? null : new SubnetEvent(SubnetEvent.Type.SUBNET_REMOVED,
                                                           subnet, null);
        }
    }

    /**
     * Returns a Subnet, merging description given from multiple Providers.
     *
     * @param subnetId subnet identifier
     * @param providerDescs Collection of Descriptions from multiple providers
     * @return Subnet instance
     */
    private Subnet composeSubnet(SubnetId subnetId,
                                 Map<ProviderId, SubnetDescriptions> providerDescs) {

        checkArgument(!providerDescs.isEmpty(),
                      "No Subnet descriptions supplied");

        ProviderId primary = pickPrimaryPID(providerDescs);

        SubnetDescriptions desc = providerDescs.get(primary);

        final SubnetDescription base = desc.getSubnetDesc();
        String subnetName = base.subnetName();
        String subnetID = base.subnetID();
        String ipVersion = base.ipVersion();
        String cidr = base.cidr();
        String cidrPrefix = base.cidrPrefix();
        String gatewayIp = base.gatewayIP();
        Boolean dhcpEnabled = base.dhcpEnabled();
        Boolean shared = base.shared();
        List<String> ipAlloc = base.ipAlloc();
        List<String> hostRoutes = base.hostRoutes();
        DefaultAnnotations annotations = DefaultAnnotations.builder().build();
        annotations = merge(annotations, base.annotations());

        for (Entry<ProviderId, SubnetDescriptions> e : providerDescs.entrySet()) {
            if (e.getKey().equals(primary)) {
                continue;
            }
            // TODO: should keep track of Description timestamp
            // and only merge conflicting keys when timestamp is newer
            // Currently assuming there will never be a key conflict between
            // providers

            // annotation merging. not so efficient, should revisit later
            annotations = merge(annotations, e.getValue().getSubnetDesc()
                    .annotations());
        }

        return new DefaultSubnet(new ProviderId("of", "foo"), SubnetId.subnetId("of:001"), null, gatewayIp,
                                 dhcpEnabled, shared, "", "",
                                 null, null, null);
    }

    /**
     * @return primary ProviderID, or randomly chosen one if none exists
     */
    private ProviderId pickPrimaryPID(Map<ProviderId, SubnetDescriptions> descsMap) {
        ProviderId fallBackPrimary = null;
        for (Entry<ProviderId, SubnetDescriptions> e : descsMap.entrySet()) {
            if (!e.getKey().isAncillary()) {
                return e.getKey();
            } else if (fallBackPrimary == null) {
                // pick randomly as a fallback in case there is no primary
                fallBackPrimary = e.getKey();
            }
        }
        return fallBackPrimary;
    }

    /**
     * Collection of Description of a Subnet and it's Ports given from a
     * Provider.
     */
    private static class SubnetDescriptions {

        private final AtomicReference<SubnetDescription> subnetDesc;
        private final ConcurrentMap<PortNumber, PortDescription> portDescs;

        public SubnetDescriptions(SubnetDescription desc) {
            this.subnetDesc = new AtomicReference<>(checkNotNull(desc));
            this.portDescs = new ConcurrentHashMap<>();
        }

        public SubnetDescription getSubnetDesc() {
            return subnetDesc.get();
        }

        /**
         * Puts SubnetDescription, merging annotations as necessary.
         *
         * @param newDesc new SubnetDescription
         * @return previous SubnetDescription
         */
        public synchronized SubnetDescription putSubnetDesc(SubnetDescription newDesc) {
            SubnetDescription oldOne = subnetDesc.get();
            SubnetDescription newOne = newDesc;
            if (oldOne != null) {
                SparseAnnotations merged = union(oldOne.annotations(),
                                                 newDesc.annotations());
                newOne = new DefaultSubnetDescription(newOne, merged);
            }
            return subnetDesc.getAndSet(newOne);
        }

        /**
         * Puts PortDescription, merging annotations as necessary.
         *
         * @param newDesc new PortDescription
         * @return previous PortDescription
         */
        public synchronized PortDescription putPortDesc(PortDescription newDesc) {
            PortDescription oldOne = portDescs.get(newDesc.portNumber());
            PortDescription newOne = newDesc;
            if (oldOne != null) {
                SparseAnnotations merged = union(oldOne.annotations(),
                                                 newDesc.annotations());
                newOne = new DefaultPortDescription(newOne, merged);
            }
            return portDescs.put(newOne.portNumber(), newOne);
        }
    }

    @Override
    public boolean createSubnet(Iterable<Subnet> subnets) {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public boolean updateSubnet(Iterable<Subnet> subnets) {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public boolean subnetExists(SubnetId subnetId) {
        // TODO Auto-generated method stub
        return false;
    }
}
